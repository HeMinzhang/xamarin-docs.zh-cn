|属性|描述|选项|
|--- |--- |--- |
|`abi.type`|**ABI 类型**&ndash;指定的模拟设备 ABI （应用程序二进制接口） 类型。 **X86**选项适用于的指令集通常称为"x86"或"ia-32。" **X86_64**选项适用于 64 位 x86 指令集。 **Armeabi v7a**选项适用于 ARM 指令集与 v7 的 ARM 扩展。 **Arm64 v8a**选项适用于支持 AArch64 ARM 指令集。|x86、x86_64、armeabi-v7a、arm64-v8a|
|`disk.cachePartition`|**缓存分区**&ndash;确定是否将使用模拟的设备 **/缓存**在设备上的分区。 **/缓存**分区 （这是最初为空） 是 Android 存储经常访问的数据和应用程序组件的位置。 如果设置为**没有**，仿真程序将不会使用 **/缓存**分区和其他`disk.cache`设置将被忽略。|yes、no|
|`disk.cachePartition.path`|**缓存分区路径**&ndash;指定开发计算机上的缓存分区图像文件。 仿真程序将使用此文件 **/缓存**分区。 输入的绝对路径或相对于仿真程序的数据目录的路径。 如果未设置，仿真程序将创建一个空的临时文件称为**cache.img**开发计算机上。 如果文件不存在，它则会被创建为一个空文件。 如果忽略此选项`disk.cachePartition`设置为**没有**。||
|`disk.cachePartition.size`|**缓存分区大小**&ndash;缓存分区文件大小 （以兆字节为单位）。 通常不需要设置此选项，除非应用将下载非常大的文件，这些文件大于 66 MB 的默认缓存大小。 如果忽略此选项`disk.cachePartition`设置为**没有**。||
|`disk.dataPartition.initPath`|**到数据分区的初始路径**&ndash;指定数据分区的初始内容。 擦除用户数据后, 仿真程序将指定文件的内容复制到用户数据 (默认情况下， **userdata qemu.img**) 而不是使用**userdata.img**作为初始版本。||
|`disk.dataPartition.path`|**到数据分区的路径**&ndash;指定用户数据分区文件。 若要配置永久性用户数据文件，请在开发计算机上输入文件名和路径。 如果文件不存在，仿真程序将从默认文件创建映像**userdata.img**，将其存储在由指定的文件名`disk.dataPartition.path`，并保存仿真程序关闭时，向其用户数据。 如果不指定路径，默认文件名为**userdata qemu.img**。 特殊值 **<temp>** 会导致创建临时文件并使用该仿真程序。 如果`disk.dataPartition.initPath`设置，其内容将复制到在启动时的 disk.dataPartition.path 文件。 注意，此选项不能留空。||
|`disk.dataPartition.size`|**数据分区大小**&ndash;兆字节为单位指定的用户数据分区的大小。||
|`disk.ramdisk.path`|**Ramdisk 路径**&ndash;到启动分区 (ramdisk) 映像的路径。 ramdisk 映像是装载系统映像之前由内核加载的系统映像的子集。 ramdisk 映像通常包含启动时的二进制文件和初始化脚本。 如果未指定此选项，默认值是**ramdisk.img**仿真程序系统目录中。||
|`disk.snapStorage.path`|**快照存储路径**&ndash;存储所有快照的快照存储文件的路径。 在执行期间进行的所有快照将被保存到此文件。 只有被保存到此文件的快照在仿真器运行期间才能被还原。 如果未指定此选项，则默认值为 snapshots.img 在仿真程序数据目录中。||
|`disk.systemPartition.initPath`|**系统分区 init 路径**&ndash;系统图像文件的只读副本路径; 具体而言，包含系统库和 API 级别和任何变体对应的数据的分区。 如果未指定此路径，默认值为 system.img 仿真程序系统目录中。||
|`disk.systemPartition.path`|**系统分区路径**&ndash;读/写系统分区映像路径。 如果未设置此路径，将创建临时文件并在指定的文件的内容初始化`disk.systemPartition.initPath`。||
|`disk.systemPartition.size`|**系统分区大小**&ndash;理想大小 （以兆字节为单位） 的系统分区。 如果实际的系统分区映像大于此设置，则会忽略此大小；否则，它指定系统分区文件可以增长到的最大大小。||
|`hw.accelerometer`|**加速**&ndash;确定模拟的设备是否包含加速传感器。 加速计帮助设备确定方向（用于自动旋转）。 加速计报告设备沿着三个传感器轴的加速情况。|yes、no|
|`hw.audioInput`|**音频录制支持**&ndash;确定模拟的设备是否可以录制音频。|yes、no|
|`hw.audioOutput`|**音频播放支持**&ndash;确定是否模拟的设备可以播放音频。|yes、no|
|`hw.battery`|**电池支持**&ndash;确定模拟的设备是否可以运行使用电池供电。|yes、no|
|`hw.camera`|**照相机支持**&ndash;确定模拟的设备是否具有相机。|yes、no|
|`hw.camera.back`|**面向后的相机**&ndash;配置后面向照相机 （用户离开镜头面）。 如果你开发计算机上使用网络摄像机以模拟上模拟的设备的面向后的照相机，此值必须设置为网络摄像机*n*，其中_n_ （如果必须只有一个网络摄像头，选择网络摄像头选择**webcam0**)。 如果设置为仿真的仿真程序模拟软件中的照相机。 若要禁用后面向照相机，请将此值设置为无。 如果启用面向后的照相机，请确保也启用`hw.camera`。|emulated、none、webcam0|
|`hw.camera.front`|**正面相机**&ndash;配置正面照相机 （向用户的小视窗面）。 如果你开发计算机上使用网络摄像机以模拟模拟设备上的正面照相机，此值必须设置为网络摄像机*n*，其中_n_ （如果必须只有一个网络摄像机选择网络摄像头选择**webcam0**)。 如果设置为仿真的仿真程序模拟软件中的相机。 若要禁用正面照相机，请将此值设置为无。 如果启用正面照相机，请确保也启用`hw.camera`。|emulated、none、webcam0|
|`hw.camera.maxHorizontalPixels`|**最大水平相机像素**&ndash;配置 （以像素为单位） 的模拟的设备的照相机的最大水平分辨率。||
|`hw.camera.maxVerticalPixels`|**最大垂直相机像素**&ndash;配置 （以像素为单位） 的模拟的设备的照相机的最大垂直分辨率。||
|`hw.cpu.arch`|**CPU 体系结构**&ndash;的 CPU 体系结构，以模拟通过虚拟设备。 如果你在使用 Intel HAXM 硬件加速，选择**x86**为 32 位 CPU。 选择**x86_64**为 64 位 HAXM 加速设备。 (请务必安装 SDK 管理器中的相应 Intel x86 系统映像： 例如，Intel x86 Atom 或 Intel x86 Atom_64。)若要模拟 ARM CPU，请选择**arm**为 32 位或选择**arm64**为 64 位 ARM CPU。 请记住，基于 ARM 的虚拟设备运行速度要比基于 x86 的那些虚拟设备慢得多，因为硬件加速不适用于 ARM。|x86、x86_64、arm、arm64|
|`hw.cpu.model`|**CPU 模型**&ndash;此值通常处于取消设置 (它将设置为一个值，派生自`hw.cpu.arch`如果未显式设置)。 但是，可以将它设置为特定于仿真器的字符串以作实验性使用。||
|`hw.dPad`|**DPad 密钥**&ndash;确定模拟的设备是否支持方向键 (DPad) 密钥。 一个 DPad 通常具有四个密钥以指示方向控件。|yes、no|
|`hw.gps`|**GPS 支持**&ndash;确定模拟的设备是否具有 GPS （全局定位系统） 接收方。|yes、no|
|`hw.gpu.enabled`|**GPU 仿真**&ndash;确定模拟的设备是否支持 GPU 仿真。 启用后，GPU 仿真会使用 Open GL for Embedded Systems 以在屏幕上呈现 2D 和 3D 图形，并且关联的 GPU 仿真模式设置会确定 GPU 仿真的实现方式。|yes、no|
|`hw.gpu.mode`|**GPU 仿真模式**&ndash;确定如何 GPU 仿真实现仿真程序。 如果选择自动，仿真程序将选择根据你的开发计算机设置的硬件和软件加速。 如果你选择的主机，仿真程序将使用开发计算机的图形处理器来执行更快呈现 GPU 仿真。 如果你的 GPU 不兼容与仿真程序，并且你是在 Windows 上，你可以尝试而不是主机的角度。 角度模式使用 DirectX 来提供类似于主机的性能。 如果你选择 mesa，仿真程序将使用 Mesa 3D 软件库呈现图形。 如果你有通过你开发计算机的图形处理器呈现的问题，请选择 mesa。 Swiftshader 模式可用来呈现比使用你的计算机的 GPU 稍微降低性能的软件中的图形。 关闭的选项 （禁用图形硬件仿真） 是一种不推荐使用的选项，可能会导致不正确的渲染，对于某些项，并因此建议不要使用。|auto、host、mesa、angle、swiftshader、off|
|`hw.gsmModem`|**GSM 调制解调器支持**&ndash;确定模拟的设备是否包括支持 GSM （全球移动通信系统） 电话服务单选系统的调制解调器。|yes、no|
|`hw.initialOrientation`|**初始屏幕方向**&ndash;模拟的设备 （纵向或横向朝模式） 上配置初始屏幕的方向。 在纵向模式下，屏幕的高度大于宽度。 在横向模式下，屏幕的宽度大于高度。 如果设备配置文件中都支持纵向和横向模式，则可以在运行仿真设备时更改方向。|portrait、landscape|
|`hw.keyboard`|**键盘支持**&ndash;确定模拟的设备是否支持键盘键盘。|yes、no|
|`hw.keyboard.charmap`|**键盘 charmap 名称**&ndash;硬件 charmap 为此设备的名称。 注意： 这应该始终是默认值**qwerty2**除非您相应地修改了系统映像。 此名称会在启动时发送到内核。 使用不正确的名称将导致虚拟设备不可用。||
|`hw.keyboard.lid`|**键盘合上盖子支持**&ndash;如果启用了键盘支持，此设置确定是否键盘键盘可以关闭/隐藏或打开/可见。 如果 hw.keyboard 设置为 false，则将忽略此设置。 注意： 默认值为 false 如果模拟的设备面向 API 级别 12 或更高版本。|yes、no|
|`hw.lcd.backlight`|**液晶背景光**&ndash;确定是否液晶背景光由模拟的模拟设备。|yes、no|
|`hw.lcd.density`|**LCD 密度**&ndash;模拟液晶显示，以密度无关的像素或 dp 计的密度 （dp 是一项虚拟像素）。 当设置为 160 dp 时，每个 dp 将对应一个物理像素。 在运行时，Android 使用此值选择和缩放适当的资源/资产以进行正确的显示呈现。|120、160、240、213、320|
|`hw.lcd.depth`|**液晶颜色深度**&ndash;模拟帧缓冲区包含用于驱动液晶显示位图颜色位的深度。 此值可以为 16 位（65,536 种可能的颜色）或 32 位（16,777,216 种颜色和透明度）。 尽管 32 位设置使仿真器运行较为缓慢，但颜色准确度更高。|16, 32|
|`hw.lcd.height`|**液晶像素高度**&ndash;构成模拟 LCD 显示器的垂直维度的像素数。||
|`hw.lcd.width`|**液晶像素宽度**&ndash;构成模拟 LCD 显示器的水平维度的像素数。||
|`hw.mainKeys`|**硬件后/主页键**&ndash;确定模拟的设备是否支持硬件返回和主页导航按钮。 你可以将此值设置为**是**如果按钮仅在软件中实现。 如果`hw.mainKeys`设置为**是**，仿真程序将不会显示导航按钮在屏幕上，但你可以使用仿真程序端面板"按"这些按钮。|yes、no|
|`hw.ramSize`|**设备 RAM 大小**&ndash;中兆字节为单位的模拟设备上的物理 RAM 量。 默认值将根据屏幕大小或外观版本来计算。 尽管增加大小可以提供更快的仿真器操作，但这将耗费开发计算机中更多的资源。||
|`hw.screen`|**触摸屏幕类型**&ndash;模拟设备上定义的屏幕的类型。 多点触控屏幕可以跟踪两个或多个手指触摸接口。 触摸屏可以检测仅单指触摸事件。 否触摸屏不会检测触控事件。|touch、multi-touch、no-touch|
|`hw.sdCard`|**SDCard 支持**&ndash;确定模拟的设备支持插入和删除的虚拟 （安全数字） 的 SD 卡。 仿真程序使用存储在你的开发计算机上处于可装入的磁盘映像来模拟实际 SD 卡设备 （请参阅 hw.sdCard.path） 的分区。|yes、no|
|`sdcard.size`|**SDCard 大小**&ndash;指定在指定的位置与虚拟 SD 卡文件的大小`hw.sdCard.path`。 （以字节为单位） 设备上可用。 如果此大小为简单的整数，它则以字节为单位指定大小。 还可以通过将 K、M 或 G 追加到大小中来以 KB、MB 或 GB 为单位指定大小。 最小大小为 9 M；最大为 1023 G。||
|`hw.sdCard.path`|**SDCard 映像路径**&ndash;指定文件名和你的开发计算机上某个 SD 卡分区图像文件的路径。 例如，此路径无法设置为**C:\sd\sdcard.img** Windows 上。||
|`hw.sensors.magnetic_field`|**磁字段传感器**&ndash;确定模拟的设备是否支持磁字段传感器。 磁场传感器（也被称为磁力计）报告沿三个传感器轴测量的环境磁场。 为需要访问指南针读数的应用启用此设置。 例如，导航应用可能需要此传感器以检测用户面朝的方向。|yes、no|
|`hw.sensors.orientation`|**方向传感器**&ndash;确定是否模拟的设备传感器值的方向提供。 方向传感器测量某个设备围绕三个物理坐标轴（x、y、z）旋转的度数。 注意，自 Android 2.2（API 级别 8）起，方向传感器已被弃用。|yes、no|
|`hw.sensors.proximity`|**邻近传感器**&ndash;确定模拟的设备是否支持邻近传感器。 此传感器测量某个物体相对于设备的视图屏幕的邻近度。 此传感器通常用于确定话筒是否正在向上靠近一个人的耳朵。|yes、no|
|`hw.sensors.temperature`|**温度传感器**&ndash;确定模拟的设备是否支持温度传感器。 此传感器测量摄氏度在设备的温度 (&deg;C)。|yes、no|
|`hw.touchScreen`|**触摸屏支持**&ndash;确定模拟的设备是否支持触摸屏。 触控屏用于在屏幕上直接操作对象。|yes、no|
|`hw.trackBall`|**跟踪球支持**&ndash;确定模拟的设备是否支持轨迹球上。|yes、no|
|`hw.useext4`|**EXT4 文件系统支持**&ndash;确定模拟的设备是否使用 Linux EXT4 文件系统进行分区。 因为文件系统类型是自动检测的，因此，此选项已被弃用并忽略。|否|
|`kernel.newDeviceNaming`|**内核新设备命名**&ndash;用于指定内核是否需要新的设备命名方案。 这通常与 Linux 3.10 内核和更高版本配合使用。 如果设置为**自动检测**，仿真程序将自动检测内核是否需要新的设备命名方案。|autodetect、yes、no|
|`kernel.parameters`|**内核参数**&ndash;指定 Linux 内核引导参数的字符串。 默认情况下，此设置将留空。||
|`kernel.path`|**内核路径**&ndash;指定 Linux 内核的路径。 如果未指定此路径，仿真程序将在内核 ranchu 的仿真程序系统目录中查找。||
|`kernel.supportsYaffs2`|**YAFFS2 分区支持**&ndash;确定内核是否支持 YAFFS2 (尚未另一个 Flash 文件系统 2) 分区。 通常情况下，这仅适用于 Linux 3.10 之前的内核。 如果设置为**自动检测**仿真程序将自动检测内核是否可以装载 YAFFS2 文件系统。|autodetect、yes、no|
|`skin.name`|**外观名称** &ndash; Android 仿真程序外观的名称。 外观是定义仿真显示的视觉对象和控件元素的文件集合，描述了 AVD 的窗口在开发计算机上的外观。 外观描述屏幕大小、按钮和整体设计，但不会影响应用的操作。||
|`skin.path`|**外观路径**&ndash;包含仿真程序外观文件的目录路径 skin.name 中指定此目录包含 hardware.ini 布局文件和外观的显示元素的图像文件。||
|`skin.dynamic`|**外观动态**&ndash;是否外观是动态的。 如果仿真器是基于指定的宽度和高度构造给定大小的外观，仿真器外观则为动态外观。|否|

