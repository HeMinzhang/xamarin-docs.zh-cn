---
title: 容器化微服务
description: 本章介绍如何使用微服务和容器生成灵活的、 可伸缩和可靠的现代云应用程序。
ms.prod: xamarin
ms.assetid: 5872ad92-04e0-4f1a-9691-79d5602f5683
ms.technology: xamarin-forms
author: davidbritch
ms.author: dabritch
ms.date: 08/07/2017
ms.openlocfilehash: 33be84bc17f72c8b70d117a0742b001f1f763d3d
ms.sourcegitcommit: 4b402d1c508fa84e4fc3171a6e43b811323948fc
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 04/23/2019
ms.locfileid: "61300679"
---
# <a name="containerized-microservices"></a>容器化微服务

开发客户端-服务器应用程序带来了专注于构建分层的应用程序在每个层中使用特定技术。 此类应用程序通常称为*整体式*应用程序，并打包到预缩放的峰值负载的硬件。 此开发方法的主要缺点是，不能轻松缩放各个组件，每个层中的组件和测试的成本之间的紧密耦合。 简单的更新可以在余下的层，造成意外的影响，因此对应用程序组件的更改需要重新测试和重新部署其整个层。

尤其是有在云中的时代，各个组件不能轻松地进行缩放。 整体式应用程序包含特定于域的功能，并通常除以前端、 业务逻辑和数据存储之类的功能层。 图 8-1 中所示，通过克隆到多台计算机上的整个应用程序缩放整体式应用程序。

![](containerized-microservices-images/monolithicapp.png "单一式应用程序缩放方法")

**图 8-1**:单一式应用程序缩放方法

## <a name="microservices"></a>微服务

微服务提供了应用程序开发和部署到不同的方法、 敏捷性、 规模和可靠性要求的现代云应用程序到适合的方法。 微服务应用程序分解为协同工作以提供应用程序的整体功能的独立组件。 术语微服务强调，应用程序应足够小，以反映独立问题，服务的组成，以便每个微服务实现单个函数。 此外，每个微服务都有明确定义约定，以便其他微服务可以进行通信并与之共享数据。 微服务的典型示例包括购物车、 库存处理、 购买子系统和支付处理。

微服务可以向外缩放独立，相比巨大的整体式应用程序一起缩放的。 这意味着，可以进行特定的功能区域，而需要更多的处理能力或网络带宽，以支持按需扩展而不是不必要地向外扩展应用程序的其他区域。 图 8-2 说明了这种方法，其中微服务部署和独立缩放，在计算机之间创建的服务实例。

![](containerized-microservices-images/microservicesapp.png "微服务应用程序缩放方法")

**图 8-2**:微服务应用程序缩放方法

微服务扩展可以是几乎瞬间完成，使应用程序可适应不断变化的负载。 例如，面向 web 的功能的应用程序中的单个微服务可能需要横向扩展以处理其他传入的流量的应用程序中的唯一微服务。

应用程序可伸缩性的经典模型是具有包含共享的外部数据存储来存储持久性数据的负载平衡、 无状态的层。 有状态微服务管理其自己的持久性数据，通常会在其放置它们的服务器上本地存储它，以避免开销的网络访问和复杂性的跨服务操作。 这使可能处理速度最快的数据，无需为缓存系统。 此外，可缩放的有状态微服务通常将数据分区在其实例，来管理一台服务器可以超过该支持的数据大小和传输吞吐量。

微服务还支持独立更新。 这种松耦合微服务之间提供快速而可靠的应用程序演变。 其独立的分布式性质支持滚动更新，其中的单个微服务实例的一个子集将更新在任何给定时间。 因此，如果检测到的问题，错误更新可以将其回滚之前的所有实例使用的错误代码或配置都更新。 同样，微服务通常使用架构版本控制，以便客户端时要应用更新，而不考虑哪些微服务实例正在传送与看到一致的版本。

因此，微服务应用程序通过单一式应用程序具有许多优点：

-   每个微服务是相对较小，易于管理和发展。
-   每个微服务可以开发和部署独立于其他服务。
-   每个微服务可以独立地向外扩展。 例如，目录服务或购物篮服务可能需要多个订购服务会向外扩展。 因此，生成的基础结构更有效地将消耗资源时向外扩展。
-   每个微服务隔离任何问题。 例如，如果在服务中问题它只会影响该服务。 其他服务可以继续处理请求。
-   每个微服务可以使用最新的技术。 由于微服务是自治的且运行的并行，最新技术和框架可用，而不要强制使用单一式应用程序可能使用较旧框架。

但是，基于微服务的解决方案也有潜在的缺点：

-   选择分区为微服务的应用程序的方式可能相当困难，因为每个微服务必须是完全独立的、 端到端，包括负责其数据源。
-   开发人员必须实现服务间通信，向应用程序的复杂性和延迟。
-   通常多个微服务之间的原子事务不可能实现。 因此，业务要求必须接受微服务之间的最终一致性。
-   在生产中，是在部署和管理系统的许多独立的服务操作复杂性。
-   客户端到微服务直接通信可以使难以重构微服务的协定。 例如，随着时间的推移如何系统分区到服务可能需要更改。 单个服务可能会拆分为两个或多个服务和两个服务可能会将合并。 当客户端直接与微服务通信时，此重构工作可能会中断与客户端应用程序兼容性。

## <a name="containerization"></a>容器化

容器化是软件开发的应用程序和其组版本化依赖项，以及其抽象化为部署清单文件的环境配置一起打包为容器映像，作为一个单元测试的方法和部署到主机操作系统。

容器是隔离，资源控制且可移植操作系统环境中，应用程序可以运行而无需涉及其他容器或主机的资源的位置。 因此，容器看起来，并且的作用类似于新安装的物理计算机或虚拟机。

图 8-3 中所示，有许多容器和虚拟机之间的相似之处。

![](containerized-microservices-images/containersvsvirtualmachines.png "微服务应用程序缩放方法")

**图 8-3**:虚拟机和容器的比较

容器运行的操作系统、 具有文件系统，并且就像物理计算机或虚拟机可以通过网络访问。 但是，技术和容器使用的概念是非常不同于虚拟机。 虚拟机包括应用程序、 必需的依赖项和完整的来宾操作系统。 容器包括应用程序以及其依赖关系，但与 （除了在特殊的虚拟机，每个容器内部运行 HYPER-V 容器） 在主机操作系统上作为独立进程运行的其他容器共享操作系统。 因此，容器共享资源，通常要求比虚拟机的资源更少。

面向容器的开发和部署方法的优点是它消除了大部分导致不一致的环境设置和使用它们的问题的问题。 此外，容器通过实例化新的容器，根据需要允许快速应用程序不断增长的功能。

创建和使用容器时的关键概念是：

-   容器主机：物理计算机或虚拟机配置为宿主容器。 容器主机将运行一个或多个容器。
-   容器映像：图像包含的分层文件系统堆叠，联合，并且是容器的基础。 映像没有状态，并且永远不会更改部署到不同的环境。
-   容器：容器是映像的运行时实例。
-   容器操作系统映像：从映像部署容器。 容器操作系统映像是构成一个容器的潜在的许多映像层中的第一个层。 容器操作系统是不可变，并且不能修改。
-   容器存储库：每次创建容器映像，映像，并在其依赖项存储在本地存储库。 这些映像可以在容器主机上重复使用多次。 容器映像还存储在公共或专用注册表，如[Docker Hub](https://hub.docker.com/)，以便它们可以跨不同的容器主机使用。

实现微服务基于应用程序和 Docker 已成为已由大多数软件平台和云供应商采用的标准容器实现时，企业将越来越多地采用容器。

EShopOnContainers 引用应用程序使用 Docker 来托管四个容器化的后端微服务，如图 8-4 中所示。

![](containerized-microservices-images/microservicesarchitecture.png "eShopOnContainers 引用应用程序后端微服务")

**图 8-4**: eShopOnContainers 引用应用程序后端微服务

参考应用程序中的后端服务的体系结构分解为协作的微服务和容器的窗体中的多个自治子系统。 每个微服务提供功能的一个面积： 标识服务、 目录服务、 订购的服务和购物篮服务。

每个微服务都有其自己的数据库，使其能够从其他微服务完全分离。 必要时，使用应用程序级事件实现不同的微服务的数据库之间的一致性。 有关详细信息，请参阅[微服务之间的通信](#communication_between_microservices)。

有关引用应用程序的详细信息，请参阅[.NET 微服务：适用于容器化 .NET 应用程序的体系结构](https://aka.ms/microservicesebook)。

<a name="communication_between_client_and_microservices" />

## <a name="communication-between-client-and-microservices"></a>客户端和微服务之间的通信

EShopOnContainers 移动应用与容器化的后端微服务使用通信*定向客户端到微服务*通信，图 8-5 中所示。

![](containerized-microservices-images/directclienttomicroservicecommunication.png "微服务应用程序缩放方法")

**图 8-5**:客户端到微服务直接通信

使用直接的客户端到微服务通信的移动应用到每个微服务直接通过其公共终结点，每个微服务是其他 TCP 端口与发出请求。 在生产中，终结点将通常映射到微服务的负载均衡器，这将请求分布到可用的实例。

> [!TIP]
> 请考虑使用 API 网关通信。 当构建大型和复杂微服务基于应用程序，但足以满足多个小型应用程序时，客户端到微服务直接通信可以有缺点。 当设计大型微服务基于有足够的微服务的应用程序，请考虑使用 API 网关通信。 有关详细信息，请参阅[.NET 微服务：适用于容器化 .NET 应用程序的体系结构](https://aka.ms/microservicesebook)。

<a name="communication_between_microservices" />

## <a name="communication-between-microservices"></a>微服务之间的通信

基于微服务的应用程序是一个分布式的系统，可能会在多台计算机上运行。 每个服务实例通常是一个进程。 因此，服务必须交互使用进程间通信协议，如 HTTP、 TCP、 高级消息队列协议 (AMQP) 或二进制协议，具体取决于每个服务的性质。

微服务微服务通信的两种常见方法是基于 HTTP 的 REST 通信时查询数据和轻量级异步消息传送跨多个微服务通信的更新时。

在多个微服务之间传播更改时，异步消息传送基于的事件驱动通信至关重要。 使用此方法时，微服务会发布事件时，值得注意时发生的情况，例如，它会更新业务实体的内容。 其他微服务订阅这些事件。 然后，当一个微服务收到事件时，它会更新自己的业务实体，这可能又会导致发布更多事件。 此发布-订阅功能，通常可以使用事件总线。

事件总线可实现发布-订阅微服务，而无需为明确感知，在图 8 6 所示的组件之间的通信。

![](containerized-microservices-images/eventbus.png "事件总线的发布-订阅")

**图 8-6:** 事件总线的发布-订阅

从应用程序的角度看，事件总线是只需发布-订阅通道通过接口公开。 但是，事件总线实现的方式而异。 例如，RabbitMQ、 Azure 服务总线或 MassTransit NServiceBus 等其他服务总线，可以使用事件总线实现。 图 8-7 显示了如何在 eShopOnContainers 引用应用程序中使用事件总线。

![](containerized-microservices-images/microservicesarchitecturewitheventbus.png "引用应用程序中的异步事件驱动通信")

**图 8-7:** 引用应用程序中的异步事件驱动通信

使用 RabbitMQ 实现 eShopOnContainers 事件总线提供了一个到多异步发布-订阅功能。 这意味着之后发布事件，可以有多个订阅服务器侦听同一事件。 图 8-9 说明了此关系。

![](containerized-microservices-images/eventdrivencommunication.png "一个对多通信")

**图 8-9**:一个对多通信

这样一种一对多的通信使用事件来实现跨多个服务，确保在服务之间的最终一致性的业务事务。 最终一致事务由一系列分布式步骤组成。 因此，当用户配置文件微服务收到 UpdateUser 命令时，它更新在其数据库中的用户的详细信息，并将 UserUpdated 事件发布到事件总线。 购物篮微服务和订购微服务订阅以接收此事件，并在响应中更新其各自数据库自己购买者的信息。

> [!NOTE]
> EShopOnContainers 事件总线，使用 RabbitMQ 实现用于仅用作概念证明。 对于生产系统，应考虑替代事件总线实现。

有关事件总线实现的信息，请参阅[.NET 微服务：适用于容器化 .NET 应用程序的体系结构](https://aka.ms/microservicesebook)。

## <a name="summary"></a>总结

微服务提供一种应用程序开发和部署的方法，可满足现代云应用程序的敏捷性、规模和可靠性要求。 微服务的主要优点之一是，它们可以独立地横向扩展，这意味着可以为了支持需求而扩展需要更多处理能力或网络带宽的特定功能区域，但不必扩展未出现需求增加的应用程序的所在区域。

容器是隔离，资源控制且可移植操作系统环境中，应用程序可以运行而无需涉及其他容器或主机的资源的位置。 实现微服务基于应用程序和 Docker 已成为已由大多数软件平台和云供应商采用的标准容器实现时，企业将越来越多地采用容器。


## <a name="related-links"></a>相关链接

- [下载电子书 (2 Mb PDF)](https://aka.ms/xamarinpatternsebook)
- [eShopOnContainers (GitHub) （示例）](https://github.com/dotnet-architecture/eShopOnContainers)
