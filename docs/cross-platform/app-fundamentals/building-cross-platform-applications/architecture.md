---
title: 第 2 部分 - 体系结构
description: 本文档介绍了有助于构建跨平台应用程序的体系结构模式。 它介绍典型的应用程序层 （数据层、 数据访问层等） 和通用移动软件模式 （MVVM，MVC，等等。）
ms.prod: xamarin
ms.assetid: 2176DB2D-E84A-3757-CFAB-04A586068D50
author: asb3993
ms.author: amburns
ms.date: 03/27/2017
ms.openlocfilehash: cfb2bddceea7717ac87bd7a78fd9cd45e8b93144
ms.sourcegitcommit: 4b402d1c508fa84e4fc3171a6e43b811323948fc
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 04/23/2019
ms.locfileid: "61285137"
---
# <a name="part-2---architecture"></a>第 2 部分 - 体系结构

构建跨平台应用程序的关键原则是创建将租借自身以便最大化的跨平台共享代码的体系结构。 遵循以下面向对象的编程原则有助于生成合理的应用程序：

-   **封装**– 确保类和甚至体系结构层仅公开执行其所需的最小 API 函数，并隐藏实现详细信息。 在类级别中，这意味着对象作为黑盒子，并使用代码不需要将知道如何在完成的任务。 在体系结构级别，这意味着实现鼓励简化的 API，可协调代表更抽象层中的代码更复杂的交互，如外观模式。 这意味着，UI 代码 （例如） 只应负责显示屏幕和接受用户输入;并永远不会直接与数据库交互。 同样的数据访问代码应只能读取和写入到数据库，但永远不会直接交互的按钮或标签。
-   **职责分离**– 确保每个组件 (在体系结构和类级别) 都有清晰且定义完善的用途。 每个组件应仅执行其定义的任务，并公开一个 API，需要使用它的其他类可以访问通过该功能。
-   **多态性**– 编程为接口 （或抽象类） 的支持多种实现方式，可以编写并在平台之间共享时仍与特定于平台的功能进行交互的核心代码。


自然结果是模仿现实世界或具有不同的逻辑层抽象实体的应用程序。 将代码分离到层使应用程序更轻松地理解、 测试和维护。 建议每个层中的代码是物理上独立 （无论是在目录或非常大的应用程序甚至不同的项目中） 以及逻辑上独立地 （使用命名空间）。

 <a name="Typical_Application_Layers" />


## <a name="typical-application-layers"></a>典型的应用程序层

在本文档和案例研究参考以下六个应用程序层：

-   **数据层**– 非易失性数据暂留，可能是一个 SQLite 数据库，但无法实现与 XML 文件或任何其他适当的机制。
-   **数据访问层**– 提供了创建、 读取、 更新、 删除 (CRUD) 访问而无需公开给调用方的实现详细信息数据在数据层周围的包装器。 例如，DAL 可能包含 SQL 语句来查询或更新的数据，但引用的代码不需要此有所了解。
-   **业务层**– （有时称为业务逻辑层或 BLL） 包含的业务实体定义 （模型） 和业务逻辑。 业务外观模式的候选项。
-   **服务访问层**– 用于在云中访问服务： 从复杂的 web 服务 (REST，JSON，WCF) 的数据和图像的简单检索到从远程服务器。 封装的网络的行为，并提供一个简单的 API 可供在应用程序和 UI 层。
-   **应用程序层**– 通常是特定于平台 （通常不在平台之间共享） 或代码的代码是特定于应用程序 （不通常可重用）。 有效测试是否可以将代码置于 UI 层与应用程序层是 （a） 到确定类是否具有任何实际显示控件或 （b） 是否无法共享它多个屏幕或设备之间 （例如。 iPhone 和 iPad）。
-   **用户界面 (UI) 层**– 面向用户的层，包含屏幕，小组件和管理这些控制器。


应用程序一定不能包含所有层 – 例如服务访问层将不会访问网络资源的应用程序中不存在。 非常简单的应用程序可能会将数据层和数据访问层合并，因为操作都是非常基本。

 <a name="Common_Mobile_Software_Patterns" />


## <a name="common-mobile-software-patterns"></a>常见的移动软件模式

模式是捕获定期的常见问题的解决方案的既定的方法。 有几个关键模式都有可用于了解在构建可维护性/易于理解的移动应用程序。

-   **模型-视图-视图模型 (MVVM)** – 模型-视图-视图模式是颇受支持数据绑定，如 Xamarin.Forms 框架。 通过将 Sdk 启用 XAML 的 Windows Presentation Foundation (WPF) 和 Silverlight; 等操作，流行其中 ViewModel 充当数据 （模型） 和数据绑定和命令的用户界面 （视图） 之间充当中介。
-   **模型-视图-控制器 (MVC)** – 常见的和经常令人误解模式中，MVC 生成用户界面时最常使用和提供用户界面屏幕 （视图），处理其背后的引擎的实际定义之间的分隔交互 （控制器），并填充它 （模型） 的数据。 模型是实际完全可选的功能，因此，了解此模式的核心在于视图和控制器。 MVC 是 iOS 应用程序的常用方法。
-   **业务外观**– 也称为管理器模式，为复杂的工作提供了简化的入口点。 例如，在任务跟踪应用程序中，可能有`TaskManager`如类方法`GetAllTasks()`， `GetTask(taskID)` ， `SaveTask (task)` ，等等。`TaskManager`类提供实际保存/检索的任务对象的内部工作机制的机制。
-   **单一实例**– 单一实例模式提供了可以根本不存在只能运行一个特定对象实例的方法。 例如，在移动应用程序中使用 SQLite 时, 只想的数据库的一个实例。 使用单一实例模式是确保这一点的简单方法。
-   **提供程序**– 一种模式首创的一个由 Microsoft （可以说是类似于策略或基本依赖关系注入） 鼓励在 Silverlight、 WPF 和 WinForms 应用程序之间的重复使用代码。 可以针对接口或抽象类，编写共享的代码和编写并使用的代码时传入特定于平台的具体实现。
-   **异步**-不用于与 Async 关键字，长时间运行的工作需要而无需用户界面或当前的处理在执行时使用模式的异步相混淆。 在最简单的形式异步模式只是介绍了，长时间运行的任务应启动另一个线程 （或类似的线程抽象，如任务），当前线程时继续处理并侦听来自后台进程的响应然后更新 UI 时返回的数据和/或状态。


每个模式将检查在更多详细信息，如其实际使用案例研究中所示。 维基百科提供更多详细的说明[MVVM](https://en.wikipedia.org/wiki/Model–view–viewmodel)， [MVC](https://en.wikipedia.org/wiki/Model–view–controller)， [Facade](https://en.wikipedia.org/wiki/Facade_pattern)，[单独](https://en.wikipedia.org/wiki/Singleton_pattern)，[策略](https://en.wikipedia.org/wiki/Strategy_pattern)并[提供程序](https://en.wikipedia.org/wiki/Provider_model)模式 (以及[设计模式](https://en.wikipedia.org/wiki/Design_Patterns)通常)。
